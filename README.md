# Notification Service

Микросервис на **Go** для отправки уведомлений через разных провайдеров. Работает с **RabbitMQ**: получает сообщения, отправляет через соответствующего провайдера и, при ошибке, публикует сообщение обратно в очередь.

## Возможности

* Подписка на очередь RabbitMQ.
* Отправка уведомлений в зависимости от типа сообщения через нужного провайдера (e-mail/SMS/пуш и т. п.).
* Повторная публикация в RabbitMQ при неудачной отправке (для ретраев/повторной обработки).

## Краткий поток

1. Сообщение попадает в RabbitMQ.
2. Сервис считывает его и определяет тип уведомления.
3. Выбирается соответствующий провайдер и выполняется отправка.
4. При ошибке сообщение публикуется обратно в очередь.

---

## Компоненты

### Publisher
Отвечает за публикацию сообщений в RabbitMQ.

**Основные методы:**
- `NewPublisher(cfg)` — инициализирует подключение и объявляет exchange.  
- `Publish(ctx, routingKey, body)` — публикует сообщение в очередь.  
- `Close()` — закрывает соединение и канал.

Используется для повторной публикации сообщений при ошибках или для генерации новых уведомлений.

### Subscriber
Подписывается на очередь и обрабатывает входящие сообщения.

**Основные методы:**
- `NewSubscriber(cfg)` — подключается к RabbitMQ и объявляет очередь.  
- `Subscribe(ctx, handler)` — запускает обработку сообщений; вызывает `handler` для каждого сообщения.  
- `Close()` — завершает подписку и закрывает соединение.

Возвращает `ack` при успешной обработке или `nack` (с возможностью повторной публикации) при ошибке.

---

## Пример сообщения

Сообщения, получаемые из очереди `notification`, имеют формат JSON:

```json
{
  "type": "EMAIL",
  "recipient": "user@example.com",
  "subject": "Wallet Top-Up",
  "body": "Your wallet has been successfully credited with 100 TJS.",
  "metadata": {
    "user_id": 123,
    "source": "wallet",
    "retry_count": 0
  }
}

